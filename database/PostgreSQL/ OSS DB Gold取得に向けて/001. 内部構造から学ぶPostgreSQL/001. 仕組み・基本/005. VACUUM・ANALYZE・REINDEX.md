## VACUUM・ANALYZE・REINDEX早見表
👉VACUUMが行うこと４つ（オプション４つ）。<br>
　  ① 不要領域/Deadタプル の回収<br>
　  ② ページ/インデックスファイルのデフラグ/再構成<br>
　  ③ XIDの凍結<br>
　  ④ 統計情報の更新 ※**ANALYZEコマンド単体でも可能だし、`VACUUM ANALYZE`でまとめて実行も可能👍**<br>
<br>
👉自動実行されるVACUUMはノーオプション。<br>

<br>
✅デフラグの対象は「テーブルファイル」「インデックスファイル」の２つ。<br>
　 → VACUUM FULLはテーブル全体をロックする超重めな処理...<br>
<br>
👉FREEZEの挙動は２つ「必要なものだけ凍結」「可能なものを全て凍結」<br/>
　 → 必要なものだけ凍結（`vacuum_freeze_min_age`以上の差があるXID）<br/>
　 → 可能なものを全て凍結（`VACUUM FREEZE`）<br/>

<img width="800px" src="https://github.com/user-attachments/assets/db4dac42-3dd7-4c9f-b422-ea5ae2a14f6e" />

## VACUUMのトリガー(いつ実行されるのか)
👉

<img width="800px" src="https://github.com/user-attachments/assets/298de805-6ca9-4d96-97ba-fd8199132462" />


## VACUUMの対象(どのページが対象となるか)



## 空き領域マップ(FSM/Free Space Map)
- 一言で表すと【**VACUUM後の空き領域を記録しておき、INSERT/UPDATE時に再利用しやすくする**】
- INSERT/UPDATEするときに「VACUUMで空いた領域ないっけ？」を知るためのやつ。
- DELETE(論理削除) → VACUUM(物理削除) → FSM登録 → INSERT/UPDATEで使う という流れ。


## 可視性マップ(VM/Visibility Map)
- 一言で表すと【**VACUUM不要なページを除外することで、VACUUMの効率を向上させる**】
- 「そのページに存在する**全て**の行が**全て**のトランザクションから見て可視である」フラグ を持つ。
- 1ページに対して1フラグ持っている -> 1ページ1bitなのでページ数が増えるほどVMファイルサイズも大きくなる。
- テーブルごとにVMファイルが存在している（`＄PGDATA/base/{DBのOID}/{テーブルのOID}.vm`）
- **(各ページに対して)VACUUMをするかどうかの判断をするために使われる👍**
  - フラグが0のページ＝死んだデータがある＝VACUUMをする必要がある。
  - フラグが1のページ＝死んだデータがない＝VACUUM不要。

### VMファイルを更新するタイミング(4つ)
1. VACUUM時にページの状態をスキャンするとき
2. ANALYZE時（クリーンなページであるかどうか）
3. クリーンなページに対してUPDATE/DELETEした時
4. INSERTによる新しいページ追加(まだVMファイルに未登録なページ)

### 「インデックスフルスキャン」の場合、可視性チェックでディスクIOが発生しない👍
SQL発行してデータ返ってくるまでは主に２ステップ「可視性チェック」「データ読込み」を踏む。
- 可視性チェック（**ディスクを読み込まずインデックスのみで完結できるのはこっち**）
  1. SELECT * FROM hoge WHERE age > 30;
  2. hogeテーブルのage > 30に該当するレコードを、インデックスを使ってみていく
  3. インデックスで各レコードのポインタを取得（ここでWHERE句の絞込はできる）
  4. ポインタ(ページ番号と行番号のペアを持ってる)に紐づくページファイルを特定。
  5. このページファイルが可視性マップに登録されている→可視でOK、次のレコードチェックへ行く。
- データ読込み
  - データが共有バッファ（キャッシュ）にあれば、ディスクI/Oは発生しない。
  - データが 共有バッファ（キャッシュ）にない場合は、ディスク→共有バッファにロードする。
