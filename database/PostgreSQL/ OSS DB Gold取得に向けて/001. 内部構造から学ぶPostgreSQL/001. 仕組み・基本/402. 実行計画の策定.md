## EXPLAINで見れる実行計画を理解する
このページで分かるようになること。
- EXPLAIN(実行計画)をもととなる統計情報について
  - pg_stats と pg_statistic の違い
  - サンプリングについて
  - 実行計画関連のパラメータ
    - random_page_cost
    - seq_page_cost
    - effective_cache_size 
  - 拡張統計について
- 実行計画の見方
  - オプションなし
    - 👉上から順に**ネストの深い計画ノード**から処理される。
    - 計画ノードの種類（色々）
      - `Seq Scan`, `Index Scan using -- on --`
      - `
    - `(cost=11.50..36.50 rows=380 width=813)`の見方
  - ANALYZEオプションあり
    - `(actual time=0.036..0.046 rows=39 loops=1)`の見方
    - `Planning Time: 0.143ms`, `Execution Time: 0.067ms`
  - BUFFERSオプションあり
    - `Buffers: shared hit=5`

## どのJOIN手法を使うかの基準
- ✅ テーブルの行数
  - NestedLoop的には、小さい方を外側にしたい。
  - Hash的には、小さい方を内側にしてハッシュテーブル化したい。 
- ✅ インデックスの有無
  - 特に内側のテーブルで効く。
- ✅ JOINの種類（INNER / OUTER）
  - INNERだと、ABどちらも軸となるので、クエリの順番が重要。
  - OUTERだと、外側/内側が必然的に決まる。
- ✅ JOINの向き（LEFT / RIGHT）
- ✅ 結合キーのカーディナリティ（＝一意性・重複の度合い）
  -　 一意性が高いと、NestedLoop向き🔴 
- ✅ WHERE句やJOIN条件の選択度（＝どれだけ絞れるか）
  - 先にWHERE句で絞ってから、AとBでJOINする....みたいな考え方
  - 結果が小さければ Nested Loop 向き🔴
- ✅ ORDER BYの有無
  - ソート済みなら Merge Join 有利🔴
- ✅ メモリ使用量の上限（`work_mem`）
  - ハッシュJOINの場合、メモリ上にハッシュテーブルを構築するので...
- ✅ 統計情報(`pg_statistic`)が最新であること
  - ✖古いと誤ったJOIN手法が最小されてしまう。 

<br><br>

## シーケンシャルスキャンは場合によってGood👍

🔴🔴🔴🔴🔴🔴🔴🔴🔴🔴🔴🔴🔴🔴🔴🔴🔴

## 実行結果が同じでも、クエリの書き方でJOIN手法が変わる
以下２つのクエリは(INNER) JOINだからcustomers/ordersどちらを軸にしていいし、実行結果は同じ👍<br>
しかし、**実行結果は同じでもクエリの順番が異なることで、JOIN手法は変わってしまう。**
```sql
SELECT * FROM customers(100件) JOIN orders(100万件) ON customers.id = orders.customer_id;
SELECT * FROM orders(100万件) JOIN customers(100件) ON orders.customer_id = customers.id;
```

### ベストアンサーの検討 -> テーブルの大小を考慮した上でIndexを適切に張る -> 意図的にNestedLoop結合を実現させる👍
customers(100件), orders(100万件)だったら、orders.customer_idにINDEXを張って、
```sql
SELECT *
FROM customers(100件)
JOIN orders(100万件)
```
のクエリにして、外側(customers) 内側(orders)でNestedLoop結合となるようにする。<br>
これだと
- 外側ループ（100件）＝ customers ✅外側のループが100件のみ
- 内側ループ（インデックス付きで高速検索可能）＝ orders ✅内側の検索はインデックス付きなので超高速

となる！
