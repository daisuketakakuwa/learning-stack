## VACUUMとは
・追記型アーキテクチャによって参照されなくなったレコードを<br/>
　〇再利用可能な空きデータファイルとする。<br/>
　✕消去してデータファイル量を小さくする。


## 🔴TBD🔴XIDの凍結処理が行われるタイミング = VACUUM???

https://www.postgresql.jp/docs/9.6/routine-vacuuming.html

## 🔴TBD🔴VACUUMで物理削除されてやっとインデックスが作り直される？





## VACUUMが行うこと
1. UPDATE/DELETEによって不要になったゴミデータの削除（行の物理削除）＝ ヒープ領域のクリーンアップ
2. 不要なトランザクション情報の整理 ＝ XIDの凍結

## VACUUMを頻繁に実行するメリット/デメリット

メリット
- 可視性マップがフラグ1になるページが増える（DeadTupleがない＝可視）
- テーブルサイズの肥大化を抑制
- フリーズの効率化（VACUUMは古いXIDをフリーズする役割もあるので）

デメリット
- CPU、I/Oリソースの消費
- 更新頻度が高いテーブルはDeadTupleが頻発する＝VACUUMはまとめてやった方がいい

## 空き領域マップ(FSM/Free Space Map)
- 一言で表すと【**VACUUM後の空き領域を記録しておき、INSERT/UPDATE時に再利用しやすくする**】
- INSERT/UPDATEするときに「VACUUMで空いた領域ないっけ？」を知るためのやつ。
- DELETE(論理削除) → VACUUM(物理削除) → FSM登録 → INSERT/UPDATEで使う という流れ。


## 可視性マップ(VM/Visibility Map)
- 一言で表すと【**VACUUM不要なページを除外することで、VACUUMの効率を向上させる**】
- 「そのページに存在する**全て**の行が**全て**のトランザクションから見て可視である」フラグ を持つ。
- 1ページに対して1フラグ持っている -> 1ページ1bitなのでページ数が増えるほどVMファイルサイズも大きくなる。
- テーブルごとにVMファイルが存在している（`＄PGDATA/base/{DBのOID}/{テーブルのOID}.vm`）
- **(各ページに対して)VACUUMをするかどうかの判断をするために使われる👍**
  - フラグが0のページ＝死んだデータがある＝VACUUMをする必要がある。
  - フラグが1のページ＝死んだデータがない＝VACUUM不要。

### VMファイルを更新するタイミング(4つ)
1. VACUUM時にページの状態をスキャンするとき
2. ANALYZE時（クリーンなページであるかどうか）
3. クリーンなページに対してUPDATE/DELETEした時
4. INSERTによる新しいページ追加(まだVMファイルに未登録なページ)

### VMファイル使うと可視性チェックにて「インデックスフルスキャン」が使えるって話
SQL発行してデータ返ってくるまでは主に２ステップ「可視性チェック」「データ読込み」を踏む。
- 可視性チェック（**ディスクを読み込まずインデックスのみで完結できるのはこっち**）
  1. SELECT * FROM hoge WHERE age > 30;
  2. hogeテーブルのage > 30に該当するレコードを、インデックスを使ってみていく
  3. インデックスで各レコードのポインタを取得（ここでWHERE句の絞込はできる）
  4. ポインタ(ページ番号と行番号のペアを持ってる)に紐づくページファイルを特定。
  5. このページファイルが可視性マップに登録されている→可視でOK、次のレコードチェックへ行く。
- データ読込み
  - データが共有バッファ（キャッシュ）にあれば、ディスクI/Oは発生しない。
  - データが 共有バッファ（キャッシュ）にない場合は、ディスク→共有バッファにロードする。
