## pg_class = オブジェクトの物理情報
- オブジェクト is
  - テーブル(relation)
  - インデックス
  - PK,FK制約 

```sql
SELECT
  oid,
  relname,
  relfilenode,
  relpages,
  reltuples
FROM
  pg_class
WHERE
  relname NOT LIKE '%pg_%';
```

## pg_locks
- テーブル単位/行単位で発生しているロックを確認できる。
- `granted`： true → ロック獲得済、false → `ロック待ち`

<img width="700px" src="https://github.com/user-attachments/assets/7cddf666-0c27-4f2a-bae4-25e5f5ad57d8" />


## locksのテーブル情報は「oid(オブジェクトID)」なので、論理名をpg_classからとってくる

- `pg_locks > relation`にはオブジェクトIDが入っている（論理名ではない）

<img width="700px" src="https://github.com/user-attachments/assets/7a470784-30dc-4954-ad75-79209ba37588" />

## どのクエリが待機(ロック待ち)なのか、pg_stat_activityからとってくる
- locks も activityも「BEプロセス」に紐づく情報なので、`pid`で紐づける。

<img width="700px" src="https://github.com/user-attachments/assets/59d607b2-cf9a-42e1-840e-1ed931985685" />


## pg_statsの見方
✅`ANALYZE`実行されて、やっとこのテーブルに表示される。<br>
✅各カラムごとの統計情報を確認できる → これらが実行計画作成時に参照される！

### null_frac
・その列がNULLの割合。<br>
・`0`ならNULLはない、`0.05`なら5%がNULL。<br>
・プランナーが「`WHERE col IS NULL`」で走査コストを見積もる時に使われる。<br>

### n_distinct
・その列に含まれる異なる値の個数（推定）<br>
<br>
・正の値 → 「実際の distinct 数」<br>
　例：500 → 値が約 500 種類ある<br>
<br>
・負の値 → 「テーブルサイズに比例する値」<br>
　例：-1 → 一意（主キーなど）<br>
　例：-0.5 → テーブル行数の 50% がユニーク<br>
<br>
・使いどころ：<br>
　= 条件 の選択度を見積もるのに使用<br>
<br>
例えば n_distinct = 500 の列で WHERE name = 'Bob' を検索するとき、プランナーは「1/500 ≈ 0.2%の行がヒット」と推定する。

### correlation
correlation が0に近い列をソートで使うなら → CLUSTER / BRIN インデックス検討

- `most_common_vals`:
- `most_common_freqs`: 
- `correlation`: 


