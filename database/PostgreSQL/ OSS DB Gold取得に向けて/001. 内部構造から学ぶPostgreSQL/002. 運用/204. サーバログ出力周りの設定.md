# デフォ：サーバログはstderrのみに出力される。
- 特定のログファイルにも出力したい場合は`logging_collector`を`true`にする👍

## `logging_collector`を`on`にして、stderrをファイルにも出力する。
```
# ログ出力先
logging_collector = on          # ログコレクターを有効化

# stderrへ出力したログを、ログファイルへ書き込まれるように
log_destination = 'stderr'      # 基本はstderrに出力（logging_collectorがstderrに吐かれたログをファイルへ転送）
log_directory = 'pg_log'        # PostgreSQL データディレクトリ内のサブディレクトリ
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'  # 日時付きファイル名
```

# サーバログ出力関連のパラメータ
### SQL関連
- ログそのものを出力する系（👉**それぞれ独立している。依存関係はない。**）
  - `log_statement` -> 実行したクエリを出力したい（`none/ddl/mod/all`設定）
    - 出力例：`statement: SELECT * FROM customers;`
  - `log_duration` -> クエリの実行時間を出力したい（bool値）
    - 出力例：`duration: 0.512 ms`
    - ↑これだけだと、何のログか分からない....ので↓
  - `log_min_duration_statement` -> 一定の実行時間超えたクエリを"実行時間"付きで出力
    - 出力例：`duration: 812.345 ms  statement: SELECT * FROM orders WHERE status = 'pending';`
    - デフォ：`-1` 単位：`ms`　`0`を設定するとすべてのSQLログが出力される。
  - ✅↑すべてを設定し、実行時間が長いクエリが１つ実行された場合、３行分のログが出る。
    - `statement: SELECT * FROM orders WHERE status = 'pending';`
    - `duration: 1000.123 ms`
    - `duration: 1000.123 ms  statement: SELECT * FROM orders WHERE status = 'pending';`;
    - 👉**なので、併用は避ける。必要なログだけ出力する。**
  - `log_min_error_statement` -> エラー終了したSQLに関して、どこまでエラーログ(レベル)を出力するか。
    - `ERROR`（デフォ）：`ERROR:  column "foo" does not exist at character 8`
    - `FATAL`：`FATAL:  out of memory`
    - `PANIC`：`PANIC:  could not write to log file`
### サーバログ全般/形式
- `log_line_prefix` -> すべてのサーバーログにprefixを設定する。
  - 設定値：`%t [%p] user=%u db=%d`なら、↓が出力される。
  - `2025-08-18 12:34:56.789 [12345] user=appuser db=appdb XXXXXXXXXXXXXXXXXX`
  - 🔴この設定ないと`duration: 0.512s`だけログ出力みたいな感じになるから、この設定はMUST。
  - デフォルト値：`%m [%p]`
    - `%m` → ミリ秒精度のタイムスタンプ（例: `2025-08-18 14:23:45.678`）
    - `%p` → サーバープロセスID（PID）（例: `12345`）
- `log_min_messages` -> 出力するログレベルの設定（デフォ：`WARN`）
- `log_temp_files`　-> 一時ファイル関連（デフォ：`-1` 単位：KB）`0`だと全て出力される。
### チェックポイント関連
- `log_checkpoints` -> チェックポイント発生時のログ(デフォ：`off`）
  - 「Checkpointに要した時間」「フラッシュしたサイズ」の２点が分かる。↓のように開始・完了のログを出す。
    - `LOG:  checkpoint starting: time`
    - `LOG:  checkpoint complete: wrote 10240 buffers (1024.0 MB) in 0.512 seconds`
### コネクション関連
- `log_connections` -> 誰が、どのDBに接続したかを出力
  - `LOG: connection authorized: user=appuser database=appdb`
- `log_disconnections`　-> セッションがどれくらい続いたか、どこから接続していたかを記録
  - `LOG:  disconnection: session time: 0:00:53.444 user=appuser database=appdb host=127.0.0.1 port=5432`
### ロック関連
- `log_lock_waits`（デフォ：`off`)
  - セッションがロックの獲得までの間に`deadlock_timeout`（デフォ：`1s`）より長く待機する場合にログメッセージを生成
  - 🔴`deadlock_timeout`設定時間経ったからDeadLockエラーになるわけではない。★確かに名前には`log_lock_waits`と`lock`を`wait`するしか書いてない...
  - 🔴`deadlock_timeout` はあくまで **診断用**（**デッドロック検出間隔**）** に近い役割です。
  - 🔴デッドロックが見つかれば → 即エラー（`ERROR: deadlock detected`）ログが出る。
  - 👉`lock_timeout` → 個々のクエリに対して「ロックが取れなければ何msでエラーにするか」を強制
  - 👉`statement_timeout` → クエリ全体に対して実行時間の上限を設定
  - 出力ログ：`LOG:  process 12345 waits for ShareLock on transaction 67890; blocked by process 23456.`
### VACUUM関連
- `log_autovacuum_min_duration`
  - 自動VACUUMに一定時間以上かかったテーブルをログに出す(デフォ：`-1`, `0`⇒全て出す）
  - ↓Deadタプルが回収された場合のログ
```
LOG:  automatic vacuum of table "public.orders": index scans: 2
LOG:  pages: 10 removed, 1190 remain, 0 skipped due to pins, 0 skipped frozen
LOG:  tuples: 234 removed, 120111 remain, 0 are dead but not yet removable
LOG:  buffer usage: 1050 hits, 150 writes, 512 fsyncs
LOG:  time: 145.678 ms
```


