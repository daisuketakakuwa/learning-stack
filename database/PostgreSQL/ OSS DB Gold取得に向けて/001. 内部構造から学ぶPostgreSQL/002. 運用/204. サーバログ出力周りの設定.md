# デフォ：サーバログはstderrのみに出力される。
- 特定のログファイルにも出力したい場合は`logging_collector`を`true`にする👍

## `logging_collector`を`on`にして、stderrをファイルにも出力する。
```
# ログ出力先
logging_collector = on          # ログコレクターを有効化

# stderrへ出力したログを、ログファイルへ書き込まれるように
log_destination = 'stderr'      # 基本はstderrに出力（logging_collectorがstderrに吐かれたログをファイルへ転送）
log_directory = 'pg_log'        # PostgreSQL データディレクトリ内のサブディレクトリ
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'  # 日時付きファイル名
```

# サーバログ出力関連のパラメータ
### SQL関連
- ログそのものを出力する系（👉**それぞれ独立している。依存関係はない。**）
  - `log_statement` -> 実行したクエリを出力したい（`none/ddl/mod/all`設定）
    - 出力例：`statement: SELECT * FROM customers;`
  - `log_duration` -> クエリの実行時間を出力したい（bool値）
    - 出力例：`duration: 0.512 ms`
    - ↑これだけだと、何のログか分からない....ので↓
  - `log_min_duration_statement` -> 一定の実行時間超えたクエリを"実行時間"付きで出力
    - 出力例：`duration: 812.345 ms  statement: SELECT * FROM orders WHERE status = 'pending';`
    - デフォ：`-1` 単位：`ms`　`0`を設定するとすべてのSQLログが出力される。
  - ✅↑すべてを設定し、実行時間が長いクエリが１つ実行された場合、３行分のログが出る。
    - `statement: SELECT * FROM orders WHERE status = 'pending';`
    - `duration: 1000.123 ms`
    - `duration: 1000.123 ms  statement: SELECT * FROM orders WHERE status = 'pending';`;
    - 👉**なので、併用は避ける。必要なログだけ出力する。**
  - `log_min_error_statement` -> エラー終了したSQLに関して、どこまでエラーログ(レベル)を出力するか。
    - `ERROR`（デフォ）：`ERROR:  column "foo" does not exist at character 8`
    - `FATAL`：`FATAL:  out of memory`
    - `PANIC`：`PANIC:  could not write to log file`
### サーバログ全般/形式
- `log_line_prefix` -> すべてのサーバーログにprefixを設定する。
  - 設定値：`%t [%p] user=%u db=%d`なら、↓が出力される。
  - `2025-08-18 12:34:56.789 [12345] user=appuser db=appdb XXXXXXXXXXXXXXXXXX`
  - 🔴この設定ないと`duration: 0.512s`だけログ出力みたいな感じになるから、この設定はMUST。
  - デフォルト値：`%m [%p]`
    - `%m` → ミリ秒精度のタイムスタンプ（例: `2025-08-18 14:23:45.678`）
    - `%p` → サーバープロセスID（PID）（例: `12345`）
- `log_min_messages` -> 出力するログレベルの設定（デフォ：`WARN`）
- `log_temp_files`　-> 一時ファイル関連（デフォ：`-1` 単位：KB）`0`だと全て出力される。
### チェックポイント関連
- `log_checkpoints` -> チェックポイント発生時のログ(デフォ：`off`）
  - 「Checkpointに要した時間」「フラッシュしたサイズ」の２点が分かる。↓のように開始・完了のログを出す。
    - `LOG:  checkpoint starting: time`
    - `LOG:  checkpoint complete: wrote 10240 buffers (1024.0 MB) in 0.512 seconds`
### コネクション関連
- `log_connections` -> 誰が、どのDBに接続したかを出力
  - `LOG: connection authorized: user=appuser database=appdb`
- `log_disconnections`　-> セッションがどれくらい続いたか、どこから接続していたかを記録
  - `LOG:  disconnection: session time: 0:00:53.444 user=appuser database=appdb host=127.0.0.1 port=5432`
### ロック関連（デッドロック周りも）
- `log_lock_waits`（デフォ：`off`)
  -  `deadlock_timeout` -> ロック待ちが発生してから、最初にデッドロック検出処理を実行するまでの待機時間（ミリ秒）
  -  `deadlock_timeout`分待ってもまだロック待ちの場合の「待機ログ」を出力するのが`log_lock_waits`。
    - 検出された場合「待機ログ」と「エラーログ」を出す。検出されない場合「待機ログ」のみ。
      - 待機ログ：`LOG:  process 12345 waits for ShareLock on transaction 67890; blocked by process 23456.`
      - エラーログ：`ERROR: deadlock detected`
- 👉`lock_timeout` → 個々のクエリに対して「ロックが取れなければ何msでエラーにするか」を強制
- 👉`statement_timeout` → クエリ全体に対して実行時間の上限を設定

#### ロック待ちになったときのデッドロック検査を遅らせてCPU負荷を下げたい！！

　ロックある → `deadlock_timeout`分待つ → `log_lock_waits: true`なら「待機ログ」を出す。
 　　　　　　　　　　　　　　　　　　　　　　　↓<br> 
　　　　　　　　　　　　　　　　　　　　　デッドロック検出 → 「エラーログ」出してロールバックして終了。<br>
 　　　　　　　　　　　　　　　　　　　　　　　↓<br>
　　　　　　　　　　　　　　　　　　　　　デッドロックちゃうから待機。<br>
 　　　　　　　　　　　　　　　　　　　　　　　↓<br>
　　　　　　　　　　　　　　　　　　　　　`lock_timeout`の設定あるなら、それを超えた時点でエラー終了。<br>
　　　　　　　　　　　　　　　　　　　　　⇒ 出力ログ：`ERROR: canceling statement due to lock timeout.`<br>
<br>
- クエリを実行 -> ロックがすぐ取れれば実行して終了
- ロック待ちになる
  - すぐにロックが取れない場合は待機状態へ
- `deadlock_timeout` まで待つ（デフォルト1秒）
  - **コストの高いデッドロック検査**を毎回しないために「少し様子を見る」
- デッドロック検査を実行
  - デッドロックが検出された場合：即座に`ERROR: deadlock detected`を返してトランザクションをロールバック
  - デッドロックが検出されなければ：単なるロック待ちなので待機を続ける
- `lock_timeout` が設定されていれば、それを超えた時点で `ERROR: canceling statement due to lock timeout`
- `lock_timeout` がなければ、ロックが解放されるまでずっと待つ

### VACUUM関連
- `log_autovacuum_min_duration`
  - 自動VACUUMに一定時間以上かかったテーブルをログに出す(デフォ：`-1`, `0`⇒全て出す）
  - ↓Deadタプルが回収された場合のログ
```
LOG:  automatic vacuum of table "public.orders": index scans: 2
LOG:  pages: 10 removed, 1190 remain, 0 skipped due to pins, 0 skipped frozen
LOG:  tuples: 234 removed, 120111 remain, 0 are dead but not yet removable
LOG:  buffer usage: 1050 hits, 150 writes, 512 fsyncs
LOG:  time: 145.678 ms
```


