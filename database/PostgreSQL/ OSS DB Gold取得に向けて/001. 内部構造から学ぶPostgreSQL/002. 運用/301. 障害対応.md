## システムカタログのIndexが破損した
```
ERROR: invalid page header in block 121 of relation "pg_catalog.2671_oid_idx"
```
解決策<br>
✅`REINDEX`コマンドでインデックスを作りなおす。<br>
✅`ignore_system_indexes`パラメータをONにする。<br>
　 → システムテーブルの読み込み時にシステムインデックスを無視する。<br>

## ページ/ブロックが読み込めない。破損しているようだ。
解決策<br>
✅`zero_damaged_pages`を`on`にする。<br>

### `zero_damaged_pages`とは
- `zero_damaged_pages`を`on`にしてテーブルを読み込むと、PostgreSQLが壊れたページを見つけるたびに警告を出し、**ページ全体を8KB分のゼロで書き戻す**。
- 👉「破損した部分」だけでなく、「破損した部分含んだページ全体」を0埋めする。
- これによりエラーを確実に無視し、正常なページに存在するテーブル内の行を取り出すことができるが、データ自体はなくなる。
- デフォルトで `off`

### 0埋めしたページはその後どうなる？
✅「空きページ」として再利用される。<br>
👉PostgreSQLのストレージマネージャは、新しい行を挿入するときにゼロページも再利用します。


## WALファイルが破損した。PostgreSQL(DBクラスタ)を起動できない。
解決策<br>
✅`pg_resetwal`コマンドで、WALを無効化する。<br>
👉WALファイルを無効化するだけ。削除するわけではない。<br>
　　　↓<br>
🔴既存の WAL セグメントはそのまま残りますが、サーバはそれを無視して新しいLSNから動き始めます。<br>
🔴当然、起動後のクラスタは論理的な整合性が保証されない状態。<br>
　　　↓<br>
そのため、起動したらすぐに`pg_dumpall`などで**論理バックアップ**を取得して、新しいクラスタに移行するのが必須となる。<br>
「論理バックアップ」であるのがポイント。物理バックアップだと破損しているWALファイルも持ち越しになる。]

### pg_resetwalコマンドの使い方
`pg_resetwal`コマンドで、以下を強制的に上書きする。
・WALの最終位置 (LSN)<br>
・次に使うトランザクションID (NextXID)<br>
・次に使うOID, MultiXact ID, Commit TSなど<br>
<br>
```
pg_resetwal -f -x <XID> $PGDATA
```
- `-f`：強制実行
- `-x`：`pg_resetwal`実行後にクラスタが次に発行するトランザクションID（NextXID）
  - 👉現行の`pg_resetwal`では
    - データディレクトリを調べて最大の既使用XIDを自動検出
    - それに+1した値を次のXIDとして設定
  - したがって、ユーザーが自分でpg_xactを覗いて計算する必要は基本的にありません。
  - 以前の古いPostgreSQL（9.3以前）や pg_resetxlog の時代には、不整合が起きた場合に手動で次のXIDを決める必要がありました。（自ら`pg_xact`を覗いて、ディレクトリ内で一番大きいな数値をもつファイル名を見て最大の既使用XIDを特定）
