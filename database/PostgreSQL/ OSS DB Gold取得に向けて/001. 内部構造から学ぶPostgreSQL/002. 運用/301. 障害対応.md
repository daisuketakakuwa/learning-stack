## 

## システムカタログのIndexが破損した場合
```
ERROR: invalid page header in block 121 of relation "pg_catalog.2671_oid_idx"
```
システムカタログ（`pg_catalog`）のインデックス（`idx`）が破損した....<br>
⇒ハードウェア障害等でまれにシステムインデックスが壊れることがある。

### 解決までの流れ１（`ignore_system_indexes`）
① DBクラスタを起動しようとする...が上記エラーが発生する。<br>
② `postgresql.conf`に**ignore_system_indexes=on**を記載して、クラスタ起動する。<br>
　⇒ これで**システムカタログのテーブルを直接読み込むので正常起動✅**<br>
　※ 🔴このパラメータはinitdb時に作成されるpostgresql.confには記載されていないため、新たに追記する必要があり🔴※<br>
③ `REINDEX SYSTEM`コマンドでインデックスを作りなおす。<br>
④ **ignore_system_indexes=off**に変更して、DBクラスタを再起動する。<br>

※インデックス再作成系<br>
　・`REINDEX INDEX idx_name` -> 特定のIndex<br>
　・`REINDEX TABLE tbl_name` -> テーブル配下のすべてのIndex<br>
　・`REINDEX DATABASE db_name` -> DB配下のユーザーオブジェクトのすべてのIndex<br>
　・`REINDEX SYSTEM db_name` -> DB配下のシステムカタログのすべてのIndex<br>

### 解決までの流れ２（スタンドアロンサーバ）
- ① DBクラスタ（postmasterプロセス）を起動しようとする...が上記エラーが発生する。
- ② **DBクラスタ（postmasterプロセス）を起動せず、修復用の緊急モードで【単発でPostgreSQLの内部プロセス】を立ち上げデータディレクトリを直接扱う。**
  - サーバープロセスとして常駐しない。
  - **ログイン/認証の概念なしで操作可能となる。**
  - クライアント接続を待ち受けない。
  - SQLを実行したら終了するワンショットモード。
- ↓**スタンドアロンサーバ**を使用するためのコマンド
  - `postgres --single -D /var/lib/postgresql/data mydb`
  - `postgres --single -D /var/lib/postgresql/data -P mydb`（🔴`-P`でシステムインデックス無視🔴）
- 解決１と同じく`REINDEX SYSTEM db_name`コマンドでインデックス再作成＆DB再起動！

## ページ/ブロックが読み込めない。破損しているようだ。
解決策<br>
✅`zero_damaged_pages`を`on`にする。<br>

### `zero_damaged_pages`とは
- `zero_damaged_pages`を`on`にしてテーブルを読み込むと、PostgreSQLが壊れたページを見つけるたびに警告を出し、**ページ全体を8KB分のゼロで書き戻す**。
- 👉「破損した部分」だけでなく、「破損した部分含んだページ全体」を0埋めする。
- これによりエラーを確実に無視し、正常なページに存在するテーブル内の行を取り出すことができるが、データ自体はなくなる。
- デフォルトで `off`

### 0埋めしたページはその後どうなる？
✅「空きページ」として再利用される。<br>
👉PostgreSQLのストレージマネージャは、新しい行を挿入するときにゼロページも再利用します。


## WALファイルが破損した。PostgreSQL(DBクラスタ)を起動できない。
解決策<br>
✅`pg_resetwal`コマンドで、WALを無効化する。<br>
👉WALファイルを無効化するだけ。削除するわけではない。<br>
　　　↓<br>
🔴既存の WAL セグメントはそのまま残りますが、サーバはそれを無視して新しいLSNから動き始めます。<br>
🔴当然、起動後のクラスタは論理的な整合性が保証されない状態。<br>
　　　↓<br>
そのため、起動したらすぐに`pg_dumpall`などで**論理バックアップ**を取得して、新しいクラスタに移行するのが必須となる。<br>
「論理バックアップ」であるのがポイント。物理バックアップだと破損しているWALファイルも持ち越しになる。]

### pg_resetwalコマンドの使い方
`pg_resetwal`コマンドで、以下を強制的に上書きする。
・WALの最終位置 (LSN)<br>
・次に使うトランザクションID (NextXID)<br>
・次に使うOID, MultiXact ID, Commit TSなど<br>
<br>
```
pg_resetwal -f -x <XID> $PGDATA
```
- `-f`：強制実行
- `-x`：`pg_resetwal`実行後にクラスタが次に発行するトランザクションID（NextXID）
  - 👉現行の`pg_resetwal`では
    - データディレクトリを調べて最大の既使用XIDを自動検出
    - それに+1した値を次のXIDとして設定
  - したがって、ユーザーが自分でpg_xactを覗いて計算する必要は基本的にありません。
  - 以前の古いPostgreSQL（9.3以前）や pg_resetxlog の時代には、不整合が起きた場合に手動で次のXIDを決める必要がありました。（自ら`pg_xact`を覗いて、ディレクトリ内で一番大きいな数値をもつファイル名を見て最大の既使用XIDを特定）
