## いろんなインデックス
- 通常のインデックス `ON users(age)`
- 複数列インデックス `ON users(name, age)`
- 部分インデックス `ON users(age) WHERE age >= 10`
- 式インデックス `ON users(LOWER(email))`

### 複数列インデックス -> 順番が重要
👉先頭の列から順番に検索条件に使わないと効果が弱い（name→ageの順でインデックスが張られる）
```sql
CREATE INDEX idx_users_name_age ON users(name, age);

-- nameだけ、またはnameとageの両方に効く
SELECT * FROM users WHERE name = 'Alice';
SELECT * FROM users WHERE name = 'Alice' AND age = 30;
-- age単体では効かない
SELECT * FROM users WHERE age = 30;
```


### 部分インデックス -> 特定の条件を満たす一部の行だけにインデックスを作る
👉列そのものではなく、計算式・関数の結果にインデックスを作る。<br>
👉通常のインデックスと同じく**割合が小さければインデックスが有効！**
```sql
CREATE INDEX idx_users_adults ON users(age) WHERE age >= 18;

-- インデックスに載る範囲のみ効果あり
SELECT * FROM users WHERE age = 30;
-- 条件(age < 18)のものはインデックスに含まれていない
SELECT * FROM users WHERE age = 10;
```


### 式インデックス(関数インデックス含む) -> 式の演算結果でインデックスを作成する
式インデックス<br>
・式に「関数呼び出し」のみ含むもの＝**関数インデックス**<br>
・式に「関数呼び出し」＋「演算子、CASE式」等が含まれるインデックス<br>

```sql
-- 関数インデックス
CREATE INDEX idx_users_lower_email ON users(LOWER(email));
-- 小文字に変換した検索が効率化される
SELECT * FROM users WHERE LOWER(email) = 'alice@example.com';
-- 通常の検索は効率化されない
SELECT * FROM users WHERE email = 'alice@example.com';

-- 式インデックス（関数呼び出し以外も「式」に含まれている）
CREATE INDEX idx_users_calc_age ON users((current_date - birth_date));
```

#### 式インデックスに利用できる関数は「IMMUTABLE」な結果を返す関数のみ
`random()`みたいな関数は毎回ランダムな値を返すけど、<br>
`upper('abc')`のような**常に同じ値**を返す関数しか式インデックスには使えないってこと。そりゃそうか。
```sql
-- IMMUTABLE
SELECT upper('abc');  -- 常に 'ABC' を返す
-- STABLE
SELECT current_date;  -- 同じクエリ内では同じ、翌日になれば変わる
-- VOLATILE
SELECT random();      -- 毎回違う値
```
<img width="800px" src="https://github.com/user-attachments/assets/c17b195e-f2b3-4ec8-b163-058b6a373529" />


