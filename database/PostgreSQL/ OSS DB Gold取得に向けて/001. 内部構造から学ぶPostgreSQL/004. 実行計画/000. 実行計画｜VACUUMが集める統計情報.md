## VACUUMで集める統計情報（pg_statistic）
<img width="700px" height="1078" alt="image" src="https://github.com/user-attachments/assets/935f8239-e65e-475c-8c71-f707588c39f2" />

## EXPLAIN(実行計画)のもととなる統計情報(pg_statistic/pg_stats)について
- EXPLAIN(実行計画)のもととなる統計情報について
  - pg_stats と pg_statistic の違い
    - 元テーブル(pg_statistic)をもとに、User向けに分かりやすくしてるのがpg_statsビュー
    - 元テーブル(pg_statistic)は内部管理用なので基本見ない。SUPERユーザーのみ参照可能。
    - ANALYZEコマンドで更新されるのは元テーブル(pg_statistic)。
    - pg_statsの`most_common_vals`,`most_common_freqs`を見て実行計画を決める！
  - サンプリングについて
    - 統計情報の収集はランダム・サンプリングを採用している。
    - サンプリング範囲は`default_statistics_target`パラメータで調整。大きいほど精度UP but ANALYZE時間が長くなる。
    - サンプリング範囲はテーブルごとに設定可能👍<br>`ALTER TABLE [テーブル名] ALTER [列名] SET STATISTICS 1000`


  - 実行計画関連のパラメータ
    - `seq_page_cost`（デフォ：1.0）
      - SeqScan
        - **テーブルの全ページを順番に読む方式**
        - 物理ストレージ上で連続したページを順次読み込みするので、ディスクの読み込みは効率的
      - 順次読み込み（Seq Scan）のコスト
    - `random_page_cost`（デフォ：4.0）
      - ランダムアクセス
        - Index経由で**一部の必要なページだけ読む(ランダムな)方式**
      - IndexScan(ランダムなページへのアクセス)の発生コストを設定。
      - 低ければIndexScanが採用されやすくなる👍
      - SSD/キャッシュ環境では 1.1〜2.0 が現実的。
    - `effective_cache_size`
      - `shared_buffers`：PostgreSQL が自分専用に確保するバッファ領域
      - `effective_cache_size`
        - 実際にメモリを確保するわけではなく、プランナーが「キャッシュされていると期待できるページ量」を推測するためのヒント
        - `shared_buffers`だけでなく OS のファイルシステムキャッシュに乗っている分も含めて見積もる
      - 数値が大きい ＝ Indexスキャンが使われやすくなる。
      - 数値が小さい ＝ Indexスキャンではなく、Fullスキャンが使われやすくなる。
      - 👉FullScanは、全ページ読み込む（古いキャッシュが押し出される）からキャッシュはあまり期待しない。
      - 👉IndexScanは、一部ページのみ読み込むのでキャッシュを期待する！！
