# SQL実行順
- JOIN
- WHERE
- GROUP BY / HAVING
- ORDER BY
- LIMIT

# 各クエリのポイント
## JOIN
- A JOIN B の場合、ABいずれかのレコード数が多すぎるとJOINに時間がかかる。
- 特にJOIN先テーブルのレコード数が多い方が遅くなるイメージ。<br>
　A(1000万) - B(1万) -> 毎回1万件からJOIN先レコードを探す。<br>
　A(1万) - B(1000万) -> 毎回1000万件からJOIN先レコードを探す。

- **JOINするテーブルのレコード数が多い場合、検索用にCテーブル(A+B)を作成する**等を検討する。<br>
  ※データ更新頻度が日次深夜であればこのやり方でOK<br>
  ※Twitterのようなリアルタイムなやつであれば、Cテーブルで運用するのは厳しいのでJOINの概念がないNoSQLの方が良い。<br>
  <img src="https://github.com/daisuketakakuwa/learning-stack/assets/66095465/ec9a9dd7-4f32-4569-95f9-31db5d91ce10" width="50%" />

- JOIN時のINDEX利用 -> 結合キーとしてBテーブルのPKを利用するのがNormalパターンでは、PKのINDEXが利用されている。

## WHERE
- AND検索は、条件A(1000万→1万) 条件B(1万→100) のように **前の絞込結果を絞り込む**形なので、
  最初の絞込でINDEXを利用してパフォーマンスをあげる...という形で**AND検索とINDEXの相性はよい。**
- OR検索は、条件A(1000万→20万) 条件B(1000万→10万) のように **各条件の絞込結果が独立している**形なので、
  **OR検索は通常テーブルフルスキャンの形をとる**。そのため**OR検索とINDEXの相性はよくない。**
- 

## ORDER BY
- filesort
- 
