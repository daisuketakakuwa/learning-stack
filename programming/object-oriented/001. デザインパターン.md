# TL;DR
✅オブジェクト指向プログラミング（OOP/Object-Oriented-Programming）<br/>
✅プログラミングにおける考え方の１つ。<br/>
👉**デザインパターン：OOPにおいて色んなプログラムで再利用できる設計パターン/ノウハウ**。<br/>

# Design Pattern
|Genre|Pattern|切り口|
|----|----|----|
|Creational|・FactoryMethod<br>・AbstractFactory<br>・Prototype<br>・Singleton|直接newしたら依存しちゃうからやめよ。<br>→ **Open-Closed原則**を実現👍|
|Sttructural|||

# Creational pattern
|Pattern|Descrition|
|----|----|
|Factory Method|TemplateOperationを持つ親クラス(Creator)が<br>子クラスであるConcreteCreatorクラスに<br>オブジェクトの生成を委ねる。|
|Abstract Factory|複数のインスタンス生成をFactoryクラスに委譲<br>→ ジャンルごとにまとめる感じ|
|Prototype|普通にCloneableIFを実装すればいいのでは？<br>また良さがわかってないなあ...|
|Singleton|DBインスタンスのような各スレッドからConcurrentに<br>アクセスされるオブジェクトに適用|

## Factory method [WIKIの説明](https://ja.wikipedia.org/wiki/Factory_Method_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3)
直接`new Hoge()`は呼び出さない。`new Hoge()`はFactoryクラスに委譲する。<br>
　↓<br>
直接`new Hoge()`を呼び出すと、何か悪いことがあるのか？<br>
　↓<br>
Hogeクラスを使う前提のコードになってしまう。<br>

### Badな例
ご覧の通り、HogeRepoクラスを利用してデータ取得する前提のコードである。
```java
public class ExportDataToCsv {
    public void exportCsv() {
        // 1. Dummyファイル配置
        // 2. Hogeデータ取得 From DB
        List<HogeDto> data = new HogeRepo().findAll();
        // 3. CSVへ出力
    }
}
```
Hogeデータに加え、FugaデータもCSV出力したい...となったのでexportHogeCsv関数を追加。<br>
→ この時点でExportDataToCsvクラスをいじることになってしまったのでNG❌
```java
public class ExportDataToCsv {
    public void exportHogeCsv() {
        // 1. Dummyファイル配置
        // 2. Hogeデータ取得 From DB
        List<HogeDto> data = new HogeRepo().findAll();
        // 3. CSVへ出力
    }
    public void exportFugaCsv() {
        // 1. Dummyファイル配置
        // 2. Fugaデータ取得 From DB
        List<FugaDto> data = new FugaRepo().findAll();
        // 3. CSVへ出力
    }
}
```
Badなポイントは<br>
👉**直接new HogeRepo()を呼んでしまったこと**<br>
👉**HogeRepoを差し替えるような修正をしたかったら既存コードいじる必要ありますよ？**<br>
という作りにしてしまったこと。<br>

### Goodな例
`new HogeRepo()`しない形にする。<br>
　↓どうやって？<br>
`new HogeRepo()`の部分はFactoryクラスに切り出し、「HogeRepoを使うのかFugaRepoを使うのか」を選択できる形にする。
```java
// Creator -> 大枠の処理/TemplateのOperationを定義する
// Creator -> ConcreteCreator経由で利用可能。
abstract class ExportDataToCsv<D> {
    // Operation ※Template methodと呼ばれる。
    public void exportCsv() {
        // 1. Dummyファイル配置
        // 2. データ取得 From DB
        List<D> data = createRepo().findAll();
        // 3. CSVへ出力
    }
    // Factory method
    protected abstract CsvDataRepo<D> createRepo();
}

// 拡張/代替が必要となりそうなデータ取得クラスは、Interfaceを定義することで差し替え可能とする👍
interface CsvDataRepo<D> {
     List<D> findAll();
}
// 拡張/代替対象となるHogeRepo,FugaRepoはIFを実装させる形にする。
class HogeRepo implements CsvDataRepo<HogeDto> {
    List<HogeDto> findAll() {// 実装 //}
}
class FugaRepo implements CsvDataRepo<FugaDto> {
    List<FugaDto> findAll() {// 実装 //}
}

// IFで差し替え可能としたデータ取得クラスを、ConcreteCreatorクラスで指定する👍
class ExportHogeDataIntoCsv extends ExportDataToCsv {
    @Override
    public CsvDataRepo<HogeDto> createRepo() {
        return new HogeRepo();
    }
}
class ExportFugaDataIntoCsv extends ExportDataToCsv {
    @Override
    public CsvDataRepo<FugaDto> createRepo() {
        return new FugaRepo();
    }
}

// CSV出力したいデータの ConcreteCreatorクラスを生成して呼び出せばOK👍
ExportDataToCsv<HogeDto> csvExporter = new ExportHogeDataIntoCsv();
csvExporter.exportCsv();
```

## Abstract Factory
TBD
## Prototype
TBD
## Singleton
TBD

# Structural pattern

## Adapter
✅外部ライブラリのIFをいい感じのIF(Adapterクラス)にカスタマイズしたい時に使う。<br>
✅外部ライブラリをラップするというアイデアはもっと採用したい。<br>

|登場人物|説明|
|----|----|
|Target Interface|いい感じのIF, expected IF|
|Adaptee|Legacyな外部ライブラリのIF|
|**Adapter***|外部ライブラリをTargetIFで利用するためのTranslationLayer|

```java
// Mediaごとにplay関数が存在する...1個にまとめたいな
public class LegacyMediaPlayer {
    public void playMp3(String fileName) {
        System.out.println("Playing MP3 file: " + fileName);
    }
    public void playMp4(String fileName) {
        System.out.println("Playing MP4 file: " + fileName);
    }
}
// MediaTypeを引数に渡すだけで 1つの関数のみで済むようにしたい。
public interface MediaPlayer {
    void play(String audioType, String fileName);
}

public class MediaAdapter implements MediaPlayer {
    private LegacyMediaPlayer legacyMediaPlayer;
    // Legacyなライブラリを依存注入
    public MediaAdapter(LegacyMediaPlayer legacyMediaPlayer) {
        this.legacyMediaPlayer = legacyMediaPlayer;
    }
    // 開発者はこのplay関数のみを呼びだせば、実質Legacyライブラリの関数を呼び出せるように👍
    @Override
    public void play(String audioType, String fileName) {
        if (audioType.equalsIgnoreCase("MP3")) {
            advancedMediaPlayer.playMp3(fileName);
        } else if (audioType.equalsIgnoreCase("MP4")) {
            advancedMediaPlayer.playMp4(fileName);
        }
    }
}
```

## Decorator [参考](https://refactoring.guru/ja/design-patterns/decorator/java/example)
✅やりたいこと -> 親,子,孫...と全て同じIFをもち、**子は親の振る舞いを一要素として自身の振る舞いをDecorateする**。<br>
✅子クラスは親クラスをフィールドにnewして、メソッド内で親の振る舞いを参照する【Decoratorクラス】<br>
<br>
例：ファイル操作（書き と 読み)

|層|読みの振る舞い|書きの振る舞い|
|----|----|----|
|① DataSource|IFメソッドのみ定義|IFメソッドのみ定義|
|② FileDataSource|ファイル書き込み|ファイル読み込み|
|③-1 EncryptionDecorator|暗号化→ファイル書き込み|ファイル読み込み→復号化|
|③-2 CompressDecorator|圧縮→ファイル書き込み|ファイル読み込み→解凍|

振る舞いがどんどん増えていく感じ。<br>
<br>
FileDataSourceクラス【親】<br>
①-1:ファイル書き込み<br>
①-2:ファイル読み込み<br>
　↓<br>
EncryptionDecorator【子】<br>
①-1:ファイル書き込み **+ ②-1:暗号化**<br>
①-2:ファイル読み込み **+ ②-2復号化**<br>
<br>
親と子ともに同じIFを持ち、子は親の振る舞いを参照＆**自身の振る舞いの一要素として利用。**<br>
<br>
`InputStream`がいい例。
```java
GzipInputStream gis = new GzipInputStream(new BufferedInputStream(new FileInputStream("/objects.gz")));
```
```java
public abstract class InputStream implements Closeable {
    public abstract int read() throws IOException;
```
↓ Decoratorクラスに該当。親クラス保持場所/フィールドを定義。
```java
public class FilterInputStream extends InputStream {
    protected volatile InputStream in;
    // このクラスを継承した子クラスはこのコンストラクタを呼び出す必要がある👍
    protected FilterInputStream(InputStream in) {
        this.in = in;
    }
```
```java
public class BufferedInputStream extends FilterInputStream {
    public BufferedInputStream(InputStream in, int size) {
        super(in);
```


